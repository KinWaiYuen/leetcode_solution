# *Count Binary Substrings*

@(算法)

给定一个字符串 `s`，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。

重复出现的子串要计算它们出现的次数。

**示例 1 :**
```powershell
输入: "00110011"
输出: 6
解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。

请注意，一些重复出现的子串要计算它们出现的次数。

另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。
```

**示例 2 :**
```powershell
输入: "10101"
输出: 4
解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。
```

**注意：**
+ `s.length` 在1到50,000之间。
+ `s` 只包含“0”或“1”字符。


## 方法：

这个方法单纯使用字符串解法是会超时的。因此我们这里需要简化判断逻辑，我们可以将`0`或者`1`连续出现作为一个区域，比如`00011000111`，表示成 `[3, 2, 3, 3]`。先将字符串转化为这样的一个数组（**注意加上最后一块的值。**），然后再累加相邻元素之间的较小值。因为子串必定取决于块数比较小的区域。

```cpp
class Solution {
public:
    int countBinarySubstrings(string s) {
        std::vector<int> vecGroup;
        int num = 0;
        int sum = 0;
        
        for (int i = 0; i < s.length(); i++)
        {
            num++;
            if (i != s.length() - 1 && s[i] != s[i+1])
            {
                vecGroup.push_back(num);
                num = 0;
            }
        }
        vecGroup.push_back(num);  // 这一句不要忘记,否则最后一截没有参与计算
                
        for (int i = 0; i < vecGroup.size() - 1; i++)
        {
            sum += min(vecGroup[i], vecGroup[i+1]);
        }
        return sum;
    }
};
```
